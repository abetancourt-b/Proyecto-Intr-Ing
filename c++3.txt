#include <WiFi.h>
#include <time.h>

// BMP280
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BMP280.h>

// SDS011
#include <SDS011.h>

// Firebase
#include "FirebaseESP32.h"
#include <addons/TokenHelper.h>
#include <addons/RTDBHelper.h>

// --------------------------
// CONFIG WiFi y Firebase
// --------------------------
#define WIFI_SSID "repetidor"
#define WIFI_PASSWORD "39727675"

#define API_KEY "AIzaSyAkZoxB2TfujfWVu_8AttZWKNKZqvSY8D4"
#define DATABASE_URL "https://estacion-de-monitoreo-b2335-default-rtdb.firebaseio.com"
#define USER_EMAIL "esp32@test.com"
#define USER_PASSWORD "123456789"

FirebaseData fb;
FirebaseAuth auth;
FirebaseConfig config;

// --------------------------
// Sensores
// --------------------------
Adafruit_BMP280 bmp;
const int MQ135_PIN = 34;

// SDS011
SDS011 sds;
float pm25, pm10;

// --------------------------
// Pines
// --------------------------
const int RED = 25;
const int BLUE = 26;
const int GREEN = 27;
const int Buzzer = 32;

// --------------------------
// NTP
// --------------------------
const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = -18000;
const int daylightOffset_sec = 0;

// --------------------------
// Timers
// --------------------------
unsigned long lastMQ = 0;
unsigned long lastBMP = 0;
unsigned long lastSDS = 0;
unsigned long lastHeartbeat = 0;

#define INTERVAL_MQ   3000
#define INTERVAL_BMP  3000
#define INTERVAL_SDS  10000   // no saturar SDS011
#define INTERVAL_HB   5000

// --------------------------
// Función timestamp REAL
// --------------------------
unsigned long getEpoch() {
  time_t now;
  time(&now);
  return now * 1000ULL;   // devolver ms para el HTML
}

// --------------------------
// Reconexión WiFi
// --------------------------
void ensureWiFi() {
  if (WiFi.status() == WL_CONNECTED) return;

  Serial.println("[WiFi] Reconectando...");
  WiFi.disconnect();
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);

  unsigned long t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 5000)
    delay(100);

  if (WiFi.status() == WL_CONNECTED)
    Serial.println("[WiFi] OK");
  else
    Serial.println("[WiFi] ERROR");
}

// --------------------------
// Reconexión Firebase
// --------------------------
void ensureFirebase() {
  if (Firebase.ready()) return;

  Serial.println("[Firebase] Reintentando conexión...");
  Firebase.reconnectWiFi(true);
}

// --------------------------
// MQ135 (mejor calibrado)
// --------------------------
float MQ135_getPPM() {
  int raw = analogRead(MQ135_PIN);
  float v = raw * (3.3 / 4095.0);

  // Estimación mejorada (NO exacta)
  float ppm = pow((v / 3.3), -1.5) * 200;

  return ppm;
}

String MQ135_risk(float ppm) {
  if (ppm < 150) return "bajo";
  if (ppm < 300) return "medio";
  return "alto";
}

// --------------------------
// Riesgo OMS PM2.5
// --------------------------
String PM_risk(float pm) {
  if (pm < 15) return "bajo";
  if (pm < 25) return "moderado";
  if (pm < 50) return "malo";
  if (pm < 75) return "muy malo";
  return "peligroso";
}

// --------------------------
// LEDs de alerta según temp
// --------------------------
void updateAlertas(float temp) {
  if (temp < 25) {
    digitalWrite(RED, HIGH);
    digitalWrite(BLUE, HIGH);
    digitalWrite(GREEN, LOW);
    digitalWrite(Buzzer, LOW);
  }
  else if (temp <= 27) {
    digitalWrite(RED, HIGH);
    digitalWrite(BLUE, LOW);
    digitalWrite(GREEN, HIGH);
    digitalWrite(Buzzer, LOW);
  }
  else {
    digitalWrite(RED, LOW);
    digitalWrite(BLUE, HIGH);
    digitalWrite(GREEN, HIGH);
    digitalWrite(Buzzer, HIGH);
  }
}

// --------------------------
void setup() {
  Serial.begin(115200);

  // WIFI
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  while (WiFi.status() != WL_CONNECTED) {
    delay(300);
    Serial.print(".");
  }
  Serial.println("\nWiFi OK");

  // NTP
  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);

  // BMP280
  if (!bmp.begin(0x76)) {
    Serial.println("ERROR: BMP280 no encontrado");
    while (1);
  }

  // SDS011 (UART2)
  sds.begin(16, 17);

  pinMode(RED, OUTPUT);
  pinMode(BLUE, OUTPUT);
  pinMode(GREEN, OUTPUT);
  pinMode(Buzzer, OUTPUT);

  // Firebase
  config.api_key = API_KEY;
  config.database_url = DATABASE_URL;
  auth.user.email = USER_EMAIL;
  auth.user.password = USER_PASSWORD;

  Firebase.begin(&config, &auth);
  while (!Firebase.ready()) delay(200);

  Serial.println("Firebase OK");
}

// --------------------------
void loop() {

  ensureWiFi();
  ensureFirebase();
  unsigned long now = millis();
  unsigned long ts = getEpoch();  // tiempo real en ms

  // --------------------------
  // HEARTBEAT
  // --------------------------
  if (now - lastHeartbeat > INTERVAL_HB) {
    Firebase.setInt(fb, "/estado/heartbeat", ts);
    lastHeartbeat = now;
  }

  // --------------------------
  // MQ135
  // --------------------------
  if (now - lastMQ > INTERVAL_MQ) {

    float ppm = MQ135_getPPM();
    String risk = MQ135_risk(ppm);

    Firebase.setFloat(fb, "/sensores/MQ135/valor", ppm);
    Firebase.setString(fb, "/sensores/MQ135/unidad", "ppm");
    Firebase.setString(fb, "/sensores/MQ135/riesgo", risk);
    Firebase.setInt(fb, "/sensores/MQ135/timestamp", ts);

    lastMQ = now;
  }

  // --------------------------
  // SDS011
  // --------------------------
  if (now - lastSDS > INTERVAL_SDS) {

    int err = sds.read(&pm25, &pm10);

    if (!err) {
      Firebase.setFloat(fb, "/sensores/SDS011/pm25", pm25);
      Firebase.setFloat(fb, "/sensores/SDS011/pm10", pm10);
      Firebase.setString(fb, "/sensores/SDS011/riesgo", PM_risk(pm25));
      Firebase.setInt(fb, "/sensores/SDS011/timestamp", ts);
    } else {
      Serial.println("[SDS011] Error de lectura.");
    }

    lastSDS = now;
  }

  // --------------------------
  // BMP280
  // --------------------------
  if (now - lastBMP > INTERVAL_BMP) {

    float temp = bmp.readTemperature();
    float pres = bmp.readPressure() / 100.0F;

    Firebase.setFloat(fb, "/sensores/BMP280/temperatura", temp);
    Firebase.setFloat(fb, "/sensores/BMP280/presion_hPa", pres);
    Firebase.setInt(fb, "/sensores/BMP280/timestamp", ts);

    updateAlertas(temp);

    lastBMP = now;
  }

  delay(10);
}
